Option Explicit

Private Const PROJECT_SHEET_NAME As String = "project"
Private Const TASK_TEMPLATE_SHEET_NAME As String = "tasks_template"

Public Sub UpdateProjectInformation()
    On Error GoTo Failed

    Dim client As IQuavisClient
    Set client = EnsureAuthenticatedClient()

    Dim rawProjects As Variant
    Set rawProjects = FetchProjects(client)

    Dim projectList As Collection
    Set projectList = ToCollection(rawProjects)

    Dim ws As Worksheet
    Set ws = EnsureProjectSheet()
    ws.Cells.ClearContents

    If projectList Is Nothing Or projectList.Count = 0 Then
        MsgBox "編集可能なプロジェクトが見つかりませんでした。", vbInformation
        Exit Sub
    End If

    Dim editable As New Collection
    Dim allFlats As New Collection
    Dim project As Variant
    For Each project In projectList
        Dim flat As Scripting.Dictionary
        On Error Resume Next
        Set flat = FlattenDictionary(project)
        If Err.Number <> 0 Then
            Err.Clear
            On Error GoTo 0
            GoTo ContinueLoop
        End If
        On Error GoTo 0

        On Error Resume Next
        flat.CompareMode = TextCompare
        On Error GoTo 0

        Dim identity As Variant
        identity = client.ProjectIdentity(project)
        Dim projectId As String
        projectId = identity(0)
        Dim projectName As String
        projectName = identity(1)

        flat("ProjectId") = projectId
        If Len(projectId) > 0 Then flat("Id") = projectId
        If Len(projectName) > 0 Then
            If Not flat.Exists("Name") Or Len(Trim$(CStr(flat("Name")))) = 0 Then
                flat("Name") = projectName
            End If
            flat("ProjectName") = projectName
        End If

        Dim hasEdit As Boolean
        Dim explicitPermission As Variant
        explicitPermission = ResolveTaskEditPermission(client, projectId, flat)

        If IsNull(explicitPermission) Then
            hasEdit = HasEditAuthority(flat, project)
        Else
            hasEdit = CBool(explicitPermission)
        End If

        If hasEdit Then
            flat("HasEditPermission") = "TRUE"
            editable.Add flat
        Else
            flat("HasEditPermission") = "FALSE"
        End If

        allFlats.Add flat
ContinueLoop:
    Next project

    Dim sourceRows As Collection
    If editable.Count > 0 Then
        Set sourceRows = editable
    Else
        Set sourceRows = allFlats
        If Not sourceRows Is Nothing And sourceRows.Count > 0 Then
            MsgBox "編集権限の判定ができなかったため、すべてのプロジェクトを表示します。必要なプロジェクトを手動で選択してください。", vbInformation
        Else
            MsgBox "編集可能なプロジェクトが見つかりませんでした。", vbInformation
            Exit Sub
        End If
    End If

    Dim projectRows As Variant
    projectRows = BuildProjectRows(sourceRows)

    If IsArray(projectRows) Then
        Dim lowerRow As Long, upperRow As Long
        Dim lowerCol As Long, upperCol As Long
        lowerRow = LBound(projectRows, 1)
        upperRow = UBound(projectRows, 1)
        lowerCol = LBound(projectRows, 2)
        upperCol = UBound(projectRows, 2)
        ws.Range(ws.Cells(lowerRow, lowerCol), ws.Cells(upperRow, upperCol)).Value = projectRows
    End If

    MsgBox "project シートを更新しました。", vbInformation
    Exit Sub

Failed:
    MsgBox "プロジェクト情報の更新に失敗しました: " & Err.Description, vbCritical
End Sub

Public Sub ExportSelectedProjectTasks()
    On Error GoTo Failed

    Dim wsProject As Worksheet
    Set wsProject = EnsureProjectSheet()

    Dim targetRow As Long
    targetRow = ResolveSelectedRow(wsProject)
    If targetRow <= 1 Then Err.Raise vbObjectError + 3100, "ExportSelectedProjectTasks", "ヘッダー行は選択できません。"

    Dim projectData As Scripting.Dictionary
    Set projectData = ReadProjectRow(wsProject, targetRow)

    Dim client As IQuavisClient
    Set client = EnsureAuthenticatedClient()

    Dim identity As Variant
    identity = client.ProjectIdentity(projectData)

    Dim projectId As String
    projectId = identity(0)
    If Len(Trim$(projectId)) = 0 Then Err.Raise vbObjectError + 3101, "ExportSelectedProjectTasks", "ProjectId を特定できません。"

    Dim projectName As String
    projectName = identity(1)
    If Len(Trim$(projectName)) = 0 Then
        If projectData.Exists("Name") Then projectName = CStr(projectData("Name"))
    End If
    If Len(Trim$(projectName)) = 0 Then
        If projectData.Exists("ProjectName") Then projectName = CStr(projectData("ProjectName"))
    End If

    Dim targetSheet As Worksheet
    Set targetSheet = CloneTasksTemplate(ThisWorkbook, projectName)

    Dim exportedCount As Long
    exportedCount = ExportTasksToWorksheet( _
                        client, _
                        projectData, _
                        targetSheet, _
                        Array("Assigns", "TaskBarStyle", "Todos", "OutputPlanDeliverables", "Progress") _
                    )

    MsgBox "シート """ & targetSheet.Name & """ に " & exportedCount & " 件のタスクを出力しました。", vbInformation
    Exit Sub

Failed:
    MsgBox "タスクの書き出しに失敗しました: " & Err.Description, vbCritical
End Sub

Public Sub UpdateActiveSheetTasks()
    On Error GoTo Failed

    Dim wsTasks As Worksheet
    Set wsTasks = ActiveSheet

    If wsTasks Is Nothing Then
        Err.Raise vbObjectError + 3400, "UpdateActiveSheetTasks", "アクティブなシートが見つかりません。"
    End If

    Dim client As IQuavisClient
    Set client = EnsureAuthenticatedClient()

    Dim wsOriginal As Worksheet
    Set wsOriginal = ResolveOriginalWorksheet(wsTasks)

    Dim results As Collection
    Set results = ApplyTaskUpdates(client, wsTasks, wsOriginal)

    If results Is Nothing Or results.Count = 0 Then
        MsgBox "黄色セルが含まれるタスクが見つかりませんでした。", vbInformation
        Exit Sub
    End If

    Dim summary As String
    summary = SummarizeResults(results)

    Dim detail As String
    Dim hasFailure As Boolean
    Dim item As Scripting.Dictionary
    For Each item In results
        Dim succeeded As Boolean
        If item.Exists("Success") Then succeeded = CBool(item("Success"))
        If Not succeeded Then hasFailure = True

        Dim rowLabel As String
        If item.Exists("RowIndex") Then
            rowLabel = CStr(item("RowIndex"))
        Else
            rowLabel = "?"
        End If

        Dim messageText As String
        If item.Exists("Message") Then
            messageText = CStr(item("Message"))
        ElseIf succeeded Then
            messageText = "Updated"
        Else
            messageText = "Failed"
        End If

        detail = detail & vbCrLf & "行 " & rowLabel & ": " & messageText
    Next item

    Dim prompt As String
    prompt = "タスクの更新が完了しました。" & vbCrLf & summary & detail

    Dim style As VbMsgBoxStyle
    If hasFailure Then
        style = vbExclamation
    Else
        style = vbInformation
    End If

    MsgBox prompt, style
    Exit Sub

Failed:
    MsgBox "タスクの更新に失敗しました: " & Err.Description, vbCritical
End Sub

Private Function EnsureProjectSheet() As Worksheet
    On Error GoTo Failed
    Set EnsureProjectSheet = ThisWorkbook.Worksheets(PROJECT_SHEET_NAME)
    Exit Function
Failed:
    Err.Raise vbObjectError + 3200, "EnsureProjectSheet", "project シートを取得できませんでした。"
End Function

Private Function ResolveSelectedRow(ByVal ws As Worksheet) As Long
    Dim selectionRange As Range

    On Error Resume Next
    Set selectionRange = ws.Parent.Application.Selection
    On Error GoTo 0

    If selectionRange Is Nothing Then
        Err.Raise vbObjectError + 3201, "ResolveSelectedRow", "project シートの行を選択してください。"
    End If

    If TypeName(selectionRange) <> "Range" Then
        Err.Raise vbObjectError + 3202, "ResolveSelectedRow", "行を特定できません。"
    End If

    If Not selectionRange.Worksheet Is ws Then
        Err.Raise vbObjectError + 3203, "ResolveSelectedRow", "project シート上のセルを選択してください。"
    End If

    ResolveSelectedRow = selectionRange.Row
End Function

Private Function ResolveOriginalWorksheet(ByVal wsTasks As Worksheet) As Worksheet
    If wsTasks Is Nothing Then Exit Function

    Dim obj As Object

    On Error Resume Next
    Set obj = CallByName(wsTasks, "GetOriginalWorksheet", VbMethod)
    On Error GoTo 0

    If Not obj Is Nothing Then
        If TypeName(obj) = "Worksheet" Then
            Set ResolveOriginalWorksheet = obj
            Exit Function
        End If
    End If

    Dim originalName As Variant
    On Error Resume Next
    originalName = CallByName(wsTasks, "OriginalWorksheetName", VbGet)
    On Error GoTo 0

    If VarType(originalName) = vbString Then
        On Error Resume Next
        Set ResolveOriginalWorksheet = wsTasks.Parent.Worksheets(CStr(originalName))
        On Error GoTo 0
        If Not ResolveOriginalWorksheet Is Nothing Then Exit Function
    End If

    Dim fallbackName As String
    fallbackName = wsTasks.Name & "_original"
    On Error Resume Next
    Set ResolveOriginalWorksheet = wsTasks.Parent.Worksheets(fallbackName)
    On Error GoTo 0
    If Not ResolveOriginalWorksheet Is Nothing Then Exit Function

    fallbackName = wsTasks.Name & " (original)"
    On Error Resume Next
    Set ResolveOriginalWorksheet = wsTasks.Parent.Worksheets(fallbackName)
    On Error GoTo 0
End Function

Private Function ReadProjectRow(ByVal ws As Worksheet, ByVal rowIndex As Long) As Scripting.Dictionary
    Dim headers As Range
    Set headers = ws.Rows(1)

    Dim colCount As Long
    colCount = headers.Columns.Count

    Dim result As Scripting.Dictionary
    Set result = New Scripting.Dictionary
    result.CompareMode = TextCompare

    Dim colIndex As Long
    For colIndex = 1 To colCount
        Dim headerText As String
        headerText = Trim$(CStr(headers.Cells(1, colIndex).Value))
        If Len(headerText) = 0 Then GoTo ContinueLoop

        Dim cellValue As Variant
        cellValue = ws.Cells(rowIndex, colIndex).Value
        result(headerText) = cellValue
ContinueLoop:
    Next colIndex

    Set ReadProjectRow = result
End Function

Private Function ToCollection(ByVal v As Variant) As Collection
    Dim c As Collection
    Set c = New Collection

    If IsObject(v) Then
        If v Is Nothing Then
            Set ToCollection = c
            Exit Function
        End If

        If TypeName(v) = "Collection" Then
            Set ToCollection = v
            Exit Function
        ElseIf TypeOf v Is Scripting.Dictionary Then
            Dim key As Variant
            For Each key In v.Keys
                c.Add v(key)
            Next key
        Else
            c.Add v
        End If
    ElseIf IsArray(v) Then
        Dim i As Long
        For i = LBound(v) To UBound(v)
            c.Add v(i)
        Next i
    ElseIf Not IsEmpty(v) Then
        c.Add v
    End If

    Set ToCollection = c
End Function

Private Function HasEditAuthority(ByVal flat As Scripting.Dictionary, Optional ByVal original As Variant) As Boolean
    If flat Is Nothing Then Exit Function

    Dim candidates As Variant
    candidates = Array( _
        "CanEdit", "Editable", "IsEditable", "HasEditPermission", _
        "Permissions.CanEdit", "Permissions.Editable", "Permissions.Edit", _
        "Privileges.Edit", "Privilege.Edit", "Rights.Edit")

    Dim key As Variant
    For Each key In candidates
        If flat.Exists(key) Then
            If NormalizeTruthValue(flat(key)) Then
                HasEditAuthority = True
                Exit Function
            End If
            If ContainsEditTokenValue(flat(key)) Then
                HasEditAuthority = True
                Exit Function
            End If
        End If
    Next key

    For Each key In flat.keys
        Dim loweredKey As String
        loweredKey = LCase$(CStr(key))

        If KeySuggestsEdit(loweredKey) Then
            If NormalizeTruthValue(flat(key)) Then
                HasEditAuthority = True
                Exit Function
            End If
            If ContainsEditTokenValue(flat(key)) Then
                HasEditAuthority = True
                Exit Function
            End If
        ElseIf KeySuggestsPermissionContainer(loweredKey) Then
            If ContainsEditTokenValue(flat(key)) Then
                HasEditAuthority = True
                Exit Function
            End If
        End If
    Next key

    If Not IsMissing(original) Then
        If InspectVariantForEdit(original) Then
            HasEditAuthority = True
        End If
    End If
End Function

Private Function KeySuggestsEdit(ByVal loweredKey As String) As Boolean
    If Len(loweredKey) = 0 Then Exit Function

    Dim normalized As String
    normalized = Replace(loweredKey, "_", " ")
    normalized = Replace(normalized, ".", " ")
    normalized = Replace(normalized, "-", " ")
    normalized = Replace(normalized, "/", " ")

    Dim token As Variant
    Dim parts() As String
    parts = Split(normalized, " ")
    For Each token In parts
        Select Case token
            Case "edit", "canedit", "iseditable", "editable", "haseditpermission", _
                 "hasedit", "editpermission", "editproject", "projectedit", _
                 "taskedit", "editauthority", "editor", "editrights", _
                 "canupdate", "updatepermission", "updateauthority", _
                 "canwrite", "writepermission", "writeauthority", "caneditproject", _
                 "canedittask"
                KeySuggestsEdit = True
                Exit Function
        End Select
    Next token
End Function

Private Function KeySuggestsPermissionContainer(ByVal loweredKey As String) As Boolean
    If Len(loweredKey) = 0 Then Exit Function

    If InStr(loweredKey, "permission") > 0 Then
        KeySuggestsPermissionContainer = True
    ElseIf InStr(loweredKey, "privilege") > 0 Then
        KeySuggestsPermissionContainer = True
    ElseIf InStr(loweredKey, "authority") > 0 Then
        KeySuggestsPermissionContainer = True
    ElseIf InStr(loweredKey, "availableaction") > 0 Then
        KeySuggestsPermissionContainer = True
    ElseIf InStr(loweredKey, "action") > 0 And InStr(loweredKey, "lastaction") = 0 Then
        KeySuggestsPermissionContainer = True
    ElseIf InStr(loweredKey, "role") > 0 And InStr(loweredKey, "roleid") = 0 Then
        KeySuggestsPermissionContainer = True
    End If
End Function

Private Function ResolveTaskEditPermission(ByVal client As IQuavisClient, _
                                           ByVal projectId As String, _
                                           ByVal destination As Scripting.Dictionary) As Variant
    ResolveTaskEditPermission = Null

    If client Is Nothing Then Exit Function
    If destination Is Nothing Then Exit Function
    If Len(Trim$(projectId)) = 0 Then Exit Function

    On Error GoTo Failed

    Dim projectRights As Variant
    Dim projectRightsAssignError As Long

    On Error Resume Next
    Set projectRights = client.GetProjectRights(projectId)
    projectRightsAssignError = Err.Number
    Err.Clear
    On Error GoTo Failed

    If projectRightsAssignError <> 0 Then
        projectRights = client.GetProjectRights(projectId)
    ElseIf Not projectRights Is Nothing Then
        Dim projectRightsFlat As Scripting.Dictionary
        Set projectRightsFlat = FlattenDictionary(projectRights, "ProjectRights")
        If Not projectRightsFlat Is Nothing Then
            Call MergeDictionaryValues(destination, projectRightsFlat)
        End If
    End If

    Dim datasetRights As Variant
    Dim datasetRightsAssignError As Long

    On Error Resume Next
    Set datasetRights = client.GetDatasetRights(projectId, "Task")
    datasetRightsAssignError = Err.Number
    Err.Clear
    On Error GoTo Failed

    If datasetRightsAssignError <> 0 Then
        datasetRights = client.GetDatasetRights(projectId, "Task")
    End If

    Dim datasetCollection As Collection
    Set datasetCollection = ToCollection(datasetRights)

    Dim editableNames As Collection
    Set editableNames = New Collection

    Dim hasDeterministicInfo As Boolean
    hasDeterministicInfo = (datasetCollection.Count = 0)

    Dim dataset As Variant
    For Each dataset In datasetCollection
        Dim datasetFlat As Scripting.Dictionary
        Set datasetFlat = FlattenDictionary(dataset)
        If datasetFlat Is Nothing Then GoTo ContinueDataset

        Dim updateFlag As Variant
        updateFlag = ExtractBooleanValue(datasetFlat, Array("Update", _
                                                           "CanUpdate", _
                                                           "Editable", _
                                                           "ActualUpdate", _
                                                           "AllowUpdate", _
                                                           "Permissions.Update", _
                                                           "Permissions.CanUpdate", _
                                                           "Rights.Update", _
                                                           "Rights.CanUpdate"))

        If IsNull(updateFlag) Then
            GoTo ContinueDataset
        End If

        hasDeterministicInfo = True

        If CBool(updateFlag) Then
            Dim datasetName As String
            datasetName = GetFirstNonEmptyText(datasetFlat, Array("Name", _
                                                                 "DisplayName", _
                                                                 "DatasetName", _
                                                                 "Dataset.DisplayName", _
                                                                 "Dataset.Name", _
                                                                 "DatasetId", _
                                                                 "TaskDomainName", _
                                                                 "TaskDomainId"))
            If Len(datasetName) > 0 Then editableNames.Add datasetName
        End If

ContinueDataset:
    Next dataset

    destination("TaskDatasetRightsRetrieved") = "TRUE"
    destination("TaskDatasetRightsCount") = datasetCollection.Count
    destination("TaskDatasetEditableCount") = editableNames.Count

    If editableNames.Count > 0 Then
        destination("TaskDatasetsEditable") = JoinCollectionText(editableNames, ", ")
    Else
        destination("TaskDatasetsEditable") = vbNullString
    End If

    If hasDeterministicInfo Then
        If editableNames.Count > 0 Then
            destination("TaskDatasetUpdatePermission") = "TRUE"
            ResolveTaskEditPermission = True
        Else
            destination("TaskDatasetUpdatePermission") = "FALSE"
            ResolveTaskEditPermission = False
        End If
    Else
        destination("TaskDatasetUpdatePermission") = "UNKNOWN"
    End If

    Exit Function

Failed:
    Debug.Print "[ResolveTaskEditPermission] " & Err.Description
    Err.Clear
End Function

Private Sub MergeDictionaryValues(ByRef target As Scripting.Dictionary, ByVal source As Scripting.Dictionary)
    If target Is Nothing Then Exit Sub
    If source Is Nothing Then Exit Sub

    Dim key As Variant
    For Each key In source.Keys
        target(key) = source(key)
    Next key
End Sub

Private Function GetFirstNonEmptyText(ByVal dict As Scripting.Dictionary, ByVal keys As Variant) As String
    If dict Is Nothing Then Exit Function

    Dim key As Variant
    For Each key In keys
        If dict.Exists(key) Then
            Dim value As Variant
            value = dict(key)
            If Not IsObject(value) Then
                If Not IsNull(value) And Not IsEmpty(value) Then
                    Dim text As String
                    text = Trim$(CStr(value))
                    If Len(text) > 0 Then
                        GetFirstNonEmptyText = text
                        Exit Function
                    End If
                End If
            End If
        End If
    Next key
End Function

Private Function ExtractBooleanValue(ByVal dict As Scripting.Dictionary, ByVal keys As Variant) As Variant
    ExtractBooleanValue = Null

    If dict Is Nothing Then Exit Function

    Dim key As Variant
    For Each key In keys
        If dict.Exists(key) Then
            Dim value As Variant
            value = dict(key)

            If IsObject(value) Then GoTo ContinueKey
            If IsNull(value) Then GoTo ContinueKey
            If IsEmpty(value) Then GoTo ContinueKey

            Select Case VarType(value)
                Case vbBoolean
                    ExtractBooleanValue = CBool(value)
                    Exit Function
                Case vbByte, vbInteger, vbLong, vbSingle, vbDouble, vbCurrency
                    ExtractBooleanValue = (CDbl(value) <> 0)
                    Exit Function
                Case vbString
                    Dim token As String
                    token = LCase$(Trim$(CStr(value)))
                    Select Case token
                        Case "true", "1", "yes", "y"
                            ExtractBooleanValue = True
                            Exit Function
                        Case "false", "0", "no", "n"
                            ExtractBooleanValue = False
                            Exit Function
                    End Select
            End Select
        End If
ContinueKey:
    Next key
End Function

Private Function JoinCollectionText(ByVal items As Collection, Optional ByVal delimiter As String = ", ") As String
    If items Is Nothing Then Exit Function
    If items.Count = 0 Then Exit Function

    Dim parts() As String
    ReDim parts(0 To items.Count - 1)

    Dim index As Long
    For index = 1 To items.Count
        parts(index - 1) = CStr(items(index))
    Next index

    JoinCollectionText = Join(parts, delimiter)
End Function

Private Function ContainsEditTokenValue(ByVal value As Variant) As Boolean
    On Error GoTo Fallback
    Dim serialized As String
    serialized = LCase$(SafeConvertToJson(value))
    On Error GoTo 0
    If ContainsEditTokenText(serialized) Then
        ContainsEditTokenValue = True
    End If
    Exit Function

Fallback:
    Err.Clear
    On Error GoTo 0
    If IsObject(value) Then Exit Function
    If IsArray(value) Then Exit Function
    If IsError(value) Then Exit Function
    If VarType(value) = vbNull Then Exit Function

    Dim text As String
    text = LCase$(Trim$(CStr(value)))
    ContainsEditTokenValue = ContainsEditTokenText(text)
End Function

Private Function ContainsEditTokenText(ByVal text As String) As Boolean
    If Len(text) = 0 Then Exit Function

    Dim tokens As Variant
    tokens = Array("""edit""", """editor""", """editproject""", """projectedit""", _
                   """taskedit""", """task_edit""", """project_edit""", "canedit", _
                   "iseditable", "editable", "editpermission", "editauthority", _
                   "hasedit", "haseditpermission", "editrights", "edit_project", _
                   "task_edit", "project_edit", """canupdate""", "canupdate", _
                   "updatepermission", "updateauthority", """update""", _
                   """canwrite""", "canwrite", "writepermission", "writeauthority", _
                   "caneditproject", "canedittask")

    Dim token As Variant
    For Each token In tokens
        If InStr(text, token) > 0 Then
            ContainsEditTokenText = True
            Exit Function
        End If
    Next token

    Dim cleaned As String
    cleaned = Replace(text, "_", " ")
    cleaned = Replace(cleaned, ".", " ")
    cleaned = Replace(cleaned, "-", " ")
    cleaned = Replace(cleaned, "/", " ")
    cleaned = Replace(cleaned, ",", " ")
    cleaned = Replace(cleaned, ":", " ")

    Dim part As Variant
    Dim parts() As String
    parts = Split(cleaned, " ")
    For Each part In parts
        Select Case part
            Case "edit", "editor", "editable", "canedit", "editproject", "projectedit", _
                 "taskedit", "canupdate", "update", "canwrite", "write", "updatepermission", _
                 "writepermission", "updateauthority", "writeauthority"
                ContainsEditTokenText = True
                Exit Function
        End Select
    Next part
End Function

Private Function InspectVariantForEdit(ByVal value As Variant) As Boolean
    On Error GoTo CleanFail

    If IsObject(value) Then
        If TypeOf value Is Scripting.Dictionary Then
            Dim key As Variant
            For Each key In value.keys
                Dim loweredKey As String
                loweredKey = LCase$(CStr(key))

                Dim item As Variant
                If IsObject(value(key)) Then
                    Set item = value(key)
                Else
                    item = value(key)
                End If

                If KeySuggestsEdit(loweredKey) Then
                    If NormalizeTruthValue(item) Then
                        InspectVariantForEdit = True
                        Exit Function
                    End If
                    If ContainsEditTokenValue(item) Then
                        InspectVariantForEdit = True
                        Exit Function
                    End If
                ElseIf KeySuggestsPermissionContainer(loweredKey) Then
                    If ContainsEditTokenValue(item) Then
                        InspectVariantForEdit = True
                        Exit Function
                    End If
                End If

                If InspectVariantForEdit(item) Then
                    InspectVariantForEdit = True
                    Exit Function
                End If
            Next key
        ElseIf TypeOf value Is Collection Then
            Dim element As Variant
            For Each element In value
                If InspectVariantForEdit(element) Then
                    InspectVariantForEdit = True
                    Exit Function
                End If
            Next element
        Else
            InspectVariantForEdit = ContainsEditTokenValue(value)
        End If
    ElseIf IsArray(value) Then
        Dim i As Long
        For i = LBound(value) To UBound(value)
            If InspectVariantForEdit(value(i)) Then
                InspectVariantForEdit = True
                Exit Function
            End If
        Next i
    Else
        InspectVariantForEdit = ContainsEditTokenValue(value)
    End If

    Exit Function

CleanFail:
    InspectVariantForEdit = False
End Function

Private Function NormalizeTruthValue(ByVal value As Variant) As Boolean
    If IsObject(value) Or IsError(value) Or IsNull(value) Or IsEmpty(value) Then Exit Function

    Select Case VarType(value)
        Case vbBoolean
            NormalizeTruthValue = value
        Case vbByte, vbInteger, vbLong, vbSingle, vbDouble, vbCurrency
            NormalizeTruthValue = (CDbl(value) <> 0)
        Case vbString
            Dim token As String
            token = LCase$(Trim$(CStr(value)))
            NormalizeTruthValue = (token = "true" Or token = "1" Or token = "yes" Or token = "y")
    End Select
End Function

Private Function CloneTasksTemplate(ByVal wb As Workbook, ByVal projectName As String) As Worksheet
    Dim templateSheet As Worksheet
    Dim originalVisibility As XlSheetVisibility

    On Error GoTo CleanFail
    Set templateSheet = wb.Worksheets(TASK_TEMPLATE_SHEET_NAME)
    originalVisibility = templateSheet.Visible

    templateSheet.Visible = xlSheetVisible
    templateSheet.Copy After:=wb.Worksheets(wb.Worksheets.Count)

    Set CloneTasksTemplate = wb.Worksheets(wb.Worksheets.Count)
    CloneTasksTemplate.Visible = xlSheetVisible
    CloneTasksTemplate.Name = GenerateUniqueSheetName(wb, projectName)

    templateSheet.Visible = originalVisibility
    Exit Function

CleanFail:
    On Error Resume Next
    If Not templateSheet Is Nothing Then templateSheet.Visible = originalVisibility
    On Error GoTo 0

    If Err.Number = 9 Then
        Err.Raise vbObjectError + 3300, "CloneTasksTemplate", "tasks_template シートが見つかりません。"
    Else
        Err.Raise Err.Number, "CloneTasksTemplate", Err.Description
    End If
End Function

Private Function GenerateUniqueSheetName(ByVal wb As Workbook, ByVal projectName As String) As String
    Dim baseName As String
    baseName = SanitizeSheetName(projectName)

    Dim candidate As String
    candidate = baseName

    Dim counter As Long
    counter = 1
    Do While SheetExists(wb, candidate)
        candidate = TruncateForSuffix(baseName, counter)
        counter = counter + 1
    Loop

    GenerateUniqueSheetName = candidate
End Function

Private Function TruncateForSuffix(ByVal baseName As String, ByVal counter As Long) As String
    Dim suffix As String
    suffix = " (" & counter & ")"

    Dim maxLength As Long
    maxLength = 31 - Len(suffix)
    If maxLength < 1 Then maxLength = 1

    TruncateForSuffix = Left$(baseName, maxLength) & suffix
End Function

Private Function SanitizeSheetName(ByVal name As String) As String
    Dim sanitized As String
    sanitized = Trim$(name)

    sanitized = Replace(sanitized, "\\", "_")
    sanitized = Replace(sanitized, "/", "_")
    sanitized = Replace(sanitized, "?", "_")
    sanitized = Replace(sanitized, "*", "_")
    sanitized = Replace(sanitized, "[", "_")
    sanitized = Replace(sanitized, "]", "_")
    sanitized = Replace(sanitized, ":", "_")
    sanitized = Replace(sanitized, Chr$(34), "_")
    sanitized = Replace(sanitized, "'", "’")

    If Len(sanitized) = 0 Then sanitized = "project"
    If Len(sanitized) > 31 Then sanitized = Left$(sanitized, 31)

    Do While Len(sanitized) > 0 And Right$(sanitized, 1) = " "
        sanitized = Left$(sanitized, Len(sanitized) - 1)
    Loop

    If Len(sanitized) = 0 Then sanitized = "project"

    SanitizeSheetName = sanitized
End Function

Private Function SheetExists(ByVal wb As Workbook, ByVal sheetName As String) As Boolean
    Dim wsCandidate As Worksheet
    On Error Resume Next
    Set wsCandidate = wb.Worksheets(sheetName)
    SheetExists = Not wsCandidate Is Nothing
    Set wsCandidate = Nothing
    On Error GoTo 0
End Function
